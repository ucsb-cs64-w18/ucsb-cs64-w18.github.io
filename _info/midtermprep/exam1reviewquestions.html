<!DOCTYPE HTML>
<html>
  <head>
    <title>Exam 1 Review</title>
  </head>

  <body>
    <h1>Exam 1 Review</h1>
    <p>
    The exam will consist of multiple-choice, short-answer questions and writing your own code. You will need to prepare by reviewing the lectures numbered 1 through 7 (i.e. including the Tuesday 1/31 lecture) and the requisite readings. In addition, you should review all 4 labs that we have done so far and this includes <b>both</b> code you've written and questions you've answered.</p>
    <p>Between this review and the labs, this information is intended to be comprehensive; there will be no material on the exam which isn't touched by either the labs or this review.
    </p>

    <h2>Data Representation</h2>
    <ol>
      <li>Convert the decimal number 39 into 8-bit binary.</li>
      <li>Convert the decimal number 40 into a two-digit hexadecimal number.</li>
      <li>Convert the hexadecimal number <code>0x45</code> into decimal.</li>
      <li>Convert the hexadecimal number <code>0x1F</code> into decimal.</li>
      <li>Convert the <b>unsigned</b> binary number <code>1001</code> into decimal.</li>
      <li>Convert the <b>signed</b> binary number <code>1001</code> into decimal.</li>
      <li>Convert -5 into binary, using two's complement.</li>
      <li>Negate the number 7, and show its binary representation.</li>
      <li>Negate the binary number <code>0110</code>, showing the result in binary.</li>
      <li>What's the quickest way to tell if a number in two's complement is negative?</li>
      <li>
        In 5 bits, what is the most <b>negative</b> value representable in <b>signed</b> form, using two's complement?
        Express your answer in both binary and decimal.
      </li>
      <li>
        In 5 bits, what is the most <b>positive</b> value representable in <b>signed</b> form, using two's complement?
        Express your answer in both binary and decimal.
      </li>
      <li>
        In 5 bits, what is the most <b>negative</b> value representable in <b>unsigned</b> form?
        Express your answer in both binary and decimal.
      </li>
      <li>
        In 5 bits, what is the most <b>positive</b> value representable in <b>unsigned</b> form?
        Express your answer in both binary and decimal.
      </li>
      <li>
        Suppose you are given the following 4-bit binary number, shown in two's complement:
        <pre><b>0110</b></pre>
        You're not told whether or not the number is signed or unsigned.
        Is this information important in knowing what the value of the number is, in decimal?
        That is, do you need to know if it's signed or unsigned to say what the decimal value is?
        Why or why not?
      </li>
      <li>
        Suppose you are given the following 4-bit binary number, shown in two's complement:
        <pre><b>1001</b></pre>
        You're not told whether or not the number is signed or unsigned.
        Is this information important in knowing what the value of the number is, in decimal?
        That is, do you need to know if it's signed or unsigned to say what the decimal value is?
        Why or why not?
      </li>
    </ol>

    <h2>Binary Arithmetic</h2>
    <ol>
      <li>
        Suppose that a binary addition was performed in a processor, and the processor set the <b>carry</b> bit at the end of the computation.
        What does this mean?
        That is, what is the significance of the carry bit being set after an addition is performed?
      </li>
      <li>
        Suppose that a binary addition was performed in a processor, and the processor set the <b>overflow</b> bit at the end of the computation.
        What does this mean?
        That is, what is the significance of the overflow bit being set after an addition is performed?
      </li>
      <li>
        Generally, the <b>carry</b> bit is ignored when performing <b>signed</b> arithmetic.
        Why?
      </li>
      <li>
        Generally, the <b>overflow</b> bit is ignored when performing <b>unsigned</b> arithmetic.
        Why?
      </li>
      <li>
        <p>Perform the following <b>addition</b>, noting whether or not the carry bit and the overflow bit get set:</p>
<pre>
 01111111
+11111111
</pre>
      </li>
      <li>
        <p>Perform the following <b>addition</b>, noting whether or not the carry bit and the overflow bit get set:</p>
<pre>
 00100101
+10110111
</pre>
      </li>
      <li>
        <p>Perform the following <b>subtraction</b>, noting whether or not the carry bit and the overflow bit get set:</p>
<pre>
 01111111
-11111111
</pre>
      </li>
      <li>
        <p>Perform the following <b>subtraction</b>, noting whether or not the carry bit and the overflow bit get set:</p>
<pre>
 00100101
-10110111
</pre>
      </li>
      <li>
        <p>Consider the following C code:</p>
<pre>
signed char x;          
for (x = 1; x > 0; x++) {
  printf("Hello\n");
}
printf("Goodbye\n");
</pre>
        <p>
          Assume the compiler performs a naive translation to assembly, and doesn't exploit any special features of C. Recall that <code>char</code> in C is represented with 1 byte. Does <code>"Goodbye\n"</code> ever get printed out? Why or why not?
      </li>
      <li>
        <p>
          Consider the following C code:
        </p>
<pre>
unsigned char x;
for (x = 0; x &lt;= MAX_UNSIGNED_CHAR; x++) {
  printf("Hello\n");
}
printf("Goodbye\n");
</pre>
        <p>
          Assume that <code>MAX_UNSIGNED_CHAR</code> holds the maximum value representable in an <code>unsigned char</code>, which is defined previously in the code. Does <code>"Goodbye\n"</code> ever get printed out?</li></p>
      </li>
    
    <h2>Bitwise Operations</h2>
    <p>
      In the following questions, <code>&amp;</code> refers to bitwise AND, <code>|</code> refers to bitwise OR, <code>^</code> refers to bitwise XOR, <code>&lt;&lt;</code> refers to shift left, and <code>&gt;&gt;</code> refers to shift right.
    </p>
    
    <ol>
      <li>
        What is the result of the following operation:
<pre>
 00011101
&amp;11011010
</pre>
      </li>
      <li>
        What is the result of the following operation:
<pre>
 00011101
|11011010
</pre>
      </li>
      <li>
        What is the result of the following operation:
<pre>
 00011101
^11011010
</pre>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the lowest 7 bits of the given input <code>i</code>, leaving the bits in their original position:</p>
<pre>
int unsignedBits0through6(int i) {
  return __________;
}
</pre>
        <p>Fill in <code>__________</code> with a <b>single bitwise expression</b> which will make the code do what it is intended to do.</p>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the next 7 bits of the given input <code>i</code>, leaving the bits in their original position::</p>
<pre>
int unsignedBits7through13(int i) {
  return __________;
}
</pre>
        <p>Fill in <code>__________</code> with a <b>single bitwise expression</b> which will make the code do what it is intended to do.</p>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the lowest 7 bits of the given input <code>i</code>, treating the result as a <b>signed</b> value, leaving the bits in their original position:</p>
<pre>
int signedBits0through6(int i) {
  __________;  
  return __________;
}
</pre>
        <p>Fill in the blanks with valid C code which will make the function do what it is intended to do.</p>
      </li>
      <li>
        <p>Consider the following C code, which is intended to extract the next 7 bits of the given input <code>i</code>, treating the result as a <b>signed</b> value, putting the bits in the rightmost position:</p>
<pre>
int signedBits7through13(int i) {
  __________;  
  return __________;
}
</pre>
        <p>Fill in the blanks with valid C code which will make the function do what it is intended to do.</p>
      </li>
      <li>
        Consider the binary value <code>00001011</code>.
        How can this be <b>multiplied</b> by 4, <b>without</b> using an instruction intented for division or multiplication?
      </li>
      <li>
        Consider the <b>signed</b> binary value <code>00001011</code>.
        How can this be <b>divided</b> by 4, <b>without</b> using an instruction intented for division or multiplication?
      </li>
      <li>
        <p>
          There is only one form of shift left, but there are two forms of shift right.
          Some questions follow about this fact:
        </p>
        <ol>
          <li>Why are there two forms of shift right?</li>
          <li>What do the two different forms of shift right do?</li>
          <li>Why is there only one form of shift left?</li>
        </ol>
      </li>
      <li>
        <p>
          Division by a power of two can be achieved via the clever use of shift right.
          However, this won't always get the same result as actual division would.
          Some questions follow about these facts:
        </p>
        <ol>
          <li>Under what conditions will shift right and division not return the same result?</li>
          <li>
            The difference in results is viewable in a difference between rounding.
            What is the difference in rounding here?
          </li>
        </ol>
      </li>
    </ol>
    
    <h2>Assembly</h2>
    <ol>
      <li>What does the <code>li</code> pseudoinstruction do?</li>
      <li>Why isn't <code>li</code> an actual MIPS instruction?</li>
      <li>
        Translate the following MIPS code using <code>li</code> to a form that uses only actual instructions (no pseudoinstructions):
<pre>
li $t0, 0xFFFFFFFF
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = 82;
int s1 = s0 &lt;&lt; 2;
int s2 = s1 * 20;
int s3 = s2 + 7;
int s4 = s3 - 24;
int s5 = s4 / 3;
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          Where <code>&lt;&lt;read integer from the user&gt;&gt;</code> is used, you should use special functionality provided by SPIM to read in an integer from the console.
          Where <code>&lt;&lt;print integer s1&gt;&gt;</code> is used, you should use special functionality provided by SPIM to print the integer stored in <code>s1</code> to the console (you might not be able to do this directly, in which case you'll need to copy the value of <code>s1</code> into another register first).
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = &lt;&lt;read integer from the user&gt;&gt;;
int s1 = 2;  
if (s0 &lt; 7) {
  s1 = 3;
}
&lt;&lt;print integer s1&gt;&gt;
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          Where <code>&lt;&lt;read integer from the user&gt;&gt;</code> is used, you should use special functionality provided by SPIM to read in an integer from the console.
          Where <code>&lt;&lt;print integer s1&gt;&gt;</code> is used, you should use special functionality provided by SPIM to print the integer stored in <code>s1</code> to the console (you might not be able to do this directly, in which case you'll need to copy the value of <code>s1</code> into another register first).
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0 = &lt;&lt;read integer from the user&gt;&gt;;
int s1 = 2;  
if (s0 &lt; 7) {
  s1 = 3;
} else {
  s1 = s0 + s0;
}         
&lt;&lt;print integer s1&gt;&gt;
</pre>
      </li>
      <li>
        <p>
          Translate the following C code into MIPS assembly.
          The variables used below should be placed in the register with the same name.
          For example, variable <code>s0</code> should be placed in register <code>$s0</code>.
          If you need additional registers than what the code below uses, use registers <code>$t0 - $t9</code>.
          You <b>do not</b> need to exit the program properly.
        </p>
<pre>
int s0;
int s1 = 1;  
for (s0 = 0; s0 &lt; 10; s0++) {
  s1 = s1 * s0;
}                
</pre>
      </li>
    </ol>
  </body>
</html>
